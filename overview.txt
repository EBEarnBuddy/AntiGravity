EARNBUDDY TECHNICAL ARCHITECTURE & STATUS REFERENCE
Generated: January 1, 2026
Version: 2.0 (Post-Optimization)
Readiness: Scalable to 10k Users

================================================================================
PART 1: EXECUTIVE SUMMARY & RECENT OPTIMIZATIONS
================================================================================

## 1.1 Core Architecture
EarnBuddy is a **Real-Time Collaboration Platform** built on the MERN stack (MongoDB, Express, React, Node.js) with Next.js App Router for the frontend. It uses a **Hybrid Communication Model**:
- **REST API (`/api/v1`)**: Handles reliable data fetching (initial loads), complex business logic, and file uploads.
- **WebSocket (Socket.io)**: Handles ephemeral events (typing, presence) and critical instantaneous updates (messaging, notifications).

## 1.2 Recent "Scale-Ready" Optimizations (Phase 17)
The following architectural changes were deployed to support 10,000+ concurrent users:

1.  **Optimistic State Management (The "No-Refetch" Policy)**
    - *Previous*: A socket event (e.g., `room:member_joined`) triggered a global `refreshTrigger` which forced the frontend to re-fetch ALL rooms via REST.
    - *Current*: Socket events carry payloads (e.g., `roomId`). Frontend hooks (`useRooms`, `useNotifications`) intercept these and strictly patch the local React state (e.g., `state.map(r => r.id === id ? { ...r, count++ } : r)`). REST is ONLY used for initial load or recovery.

2.  **Cursor-Based Chat Pagination**
    - *Previous*: Fixed limit of 50 messages. No access to history.
    - *Current*: Implemented `GET /rooms/:id/messages?before=<MessageID>`. Frontend `useRoomMessages` manages a `messages` array by prepending older chunks while maintaining scroll position. Supported by MongoDB `_id` indexing.

3.  **High-Performance Database Indexing**
    - **RoomMembership**: `Index({ room: 1, user: 1 }, { unique: true })` ensures data integrity.
    - **RoomMembership**: `Index({ user: 1, status: 1 })` allows `getMyRooms` (the most frequent query) to execute in O(log n) time.
    - **Notification**: `Index({ recipient: 1, isRead: 1 })` allows instant calculation of unread badges.

================================================================================
PART 2: BACKEND ARCHITECTURE (DEEP DIVE)
================================================================================

## 2.1 Repository Structure (`/backend`)
- **`src/app.ts`**: Express app entry point. Configures Middleware (CORS, Helmet, Rate Limiter) and Routes.
- **`src/socket.ts`**: Socket.io Server logic. Manages connection lifecycle, Redis Adapter (for multi-instance scaling), and event routing.
- **`src/controllers/*`**: Business logic. Separated from Routes.
- **`src/models/*`**: Mongoose Schemas (ODM).
- **`src/services/*`**: Singleton services (Redis, etc.).

## 2.2 Authentication Flow (Firebase + Hybrid)
1.  **Client**: Signs in via Firebase Client SDK -> Receives ID Token (JWT).
2.  **Request**: Client sends `Authorization: Bearer <ID_TOKEN>`.
3.  **Middleware (`auth.ts`)**:
    - Decodes ID Token using `firebase-admin`.
    - Extracts `uid` (Firebase UID).
    - Attaches `req.user = { uid, email }` to request.
    - *Optimization*: Does NOT hit MongoDB for every request. Only controllers that need full Profile data query MongoDB.

## 2.3 Real-Time Infrastructure
- **Engine**: Socket.io v4.
- **Transport**: Polling -> WebSocket Upgrade.
- **Scaling**: Uses `@socket.io/redis-adapter` to sync events across multiple Node.js instances.
- **Security**: Socket handshake requires `auth: { token }` which is validated against Firebase.
- **Room Strategy**:
    - `io.join('user:<UID>')`: Personal channel for private notifications.
    - `io.join('<RoomID>')`: Public/Private Group channels.

## 2.4 Data Models (Critical Schemas)

### User
- *Key Fields*: `firebaseUid` (Index), `username` (Unique), `email`, `role` (freelancer/founder/etc).
- *Relationships*: Linked to `RoomMembership`, `Application`, `Opportunity`.

### Room (Circles)
- *Key Fields*: `name`, `slug` (Unique), `type` (community/collab/opportunity), `membersCount` (Denormalized Counter).
- *Logic*: `isPrivate` determines visibility. `membersCount` is updated via atomic `$inc` operations.

### RoomMembership
- *Purpose*: Pivot table for User <-> Room many-to-many relationship.
- *Fields*: `room`, `user`, `role` (admin/member), `status` (pending/accepted).
- *Indexes*: Compound `(room, user)` unique.

### Message
- *Key Fields*: `room` (Ref), `sender` (Ref), `content`, `type` (text/image/system), `readBy` (Array of objects).
- *Optimizations*: Indexed by `{ room: 1, createdAt: -1 }`.
- *Warning*: `readBy` array grows linearly with room size. Future optimization needed for 50k+ users.

### Opportunity (Startups/Gigs)
- *Key Fields*: `type` (startup/project alias 'gig'), `roles` (Embedded Array), `status`.
- *Architecture*: Uses a unified model for both "Startups" and "Freelance Gigs" to simplify search, but Frontend treats them as distinct features.

================================================================================
PART 3: FRONTEND ARCHITECTURE (DEEP DIVE)
================================================================================

## 3.1 Stack Codebase (`/frontend`)
- **Next.js 16 (App Router)**: Uses server components for Layouts (`layout.tsx`) but mostly Client Components for interactive dashboard features.
- **Tailwind v4**: Style system.
- **State**: Strictly React Context + Hooks. No Redux/Zustand (simplicity preferred).

## 3.2 Key Hooks Strategy (`useFirestore.ts`)
This file is the "Brain" of the frontend data layer.
- **`useRooms`**:
    - *Fetch*: `GET /api/v1/rooms` + `GET /api/v1/rooms/me`.
    - *Merge*: Combines Public and Private lists.
    - *Socket*: Listens for `room:created` (append to public), `room:member_joined` (update local counts).
- **`useRoomMessages`** (Chat Engine):
    - *Fetch*: `GET /rooms/:id/messages`.
    - *Pagination*: Uses `loadMore()` with `before` cursor.
    - *Realtime*: Listens for `new_message` -> Appends to array -> Dedupes based on ID.
- **`useNotifications`**:
    - *Hybrid*: Polls every 30s (safety net) BUT relies on `socket.on('notification:new')` for instant UX.

## 3.3 Folder Structure
- **`/app/(protected)`**: Routes requiring authentication. Wrapped in `AuthGuard`.
    - **/circles**: Chat & Community Logic.
    - **/startups**: Opportunity Listings.
    - **/dashboard**: User Homepage.
- **`/components`**:
    - **UI**: Reusable primitives (Buttons, Modals).
    - **Feature**: complex blocks (`ChatWindow`, `CircleCard`).

================================================================================
PART 4: EVENT DICTIONARY (SOCKET PROTOCOL)
================================================================================

| Event Name | Direction | Payload | Description |
| :--- | :--- | :--- | :--- |
| `join_room` | Client->Server | `roomId` | Subscribes socket to room channel. |
| `leave_room` | Client->Server | `roomId` | Unsubscribes. |
| `typing` | Client->Server | `{ roomId, userId, userName }` | Broadcasts typing status. |
| `stop_typing` | Client->Server | `{ roomId, userId }` | Clears typing status. |
| `new_message` | Server->Client | `Message` Object | Complete message doc (populated sender). |
| `message_updated` | Server->Client | `Message` Object | Edited content. |
| `message_deleted` | Server->Client | `{ messageId, roomId }` | Frontend removes from state. |
| `room:member_joined` | Server->Client | `{ roomId, userId }` | Triggers count increment. |
| `notification:new` | Server->Client | `Notification` Object | System wide alert. |

================================================================================
PART 5: SCALING & LIMITATIONS (HONEST ASSESSMENT)
================================================================================

## 5.1 Ready for
- **10,000 Users**:
    - Chat is stable (Redis Adapter + Pagination).
    - Room Lists are stable (Optimistic Updates prevent ddos).
    - Indexes prevent DB scanning.

## 5.2 Next Bottlenecks (At 50k - 100k Users)
1.  **Notification Counters**: `useNotifications` counts array length in frontend. For 1000+ unread notifications, this is heavy. Backend needs a `HEAD /notifications/unread` count endpoint.
2.  **`readBy` Array**: In a defined "General" room with 50,000 members, a single message document cannot hold 50k read receipts (16MB Doc Limit). Strategy must shift to "Watermark" (User X read up to Time Y).
3.  **Initial Load**: `GET /rooms` fetches ALL public rooms. As platform grows to 10k rooms, this must become paginated or search-based.

## 5.3 Deployment Requirements
- **Redis**: MANDATORY for Socket.io.
- **Sticky Sessions**: Required if using multiple Backend nodes (handled by Nginx/load balancer usually, or native Websocket usage).
- **SSL**: Secure Websockets (`wss://`) required for production.
