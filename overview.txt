EARNBUDDY TECHNICAL STATUS OVERVIEW
Generated: January 1, 2026
Purpose: Realistic codebase assessment for scaling 10k users.

================================================================================
SECTION 1: REPOSITORY OVERVIEW
================================================================================
Structure: Monorepo (Root contains /frontend and /backend directories)

1. Frontend (/frontend)
   - Framework: Next.js 16.0.7 (App Router), React 19.2.0
   - Styling: TailwindCSS v4, Class Variance Authority (CVA), Lucide-React
   - Core Path: /frontend/app (App Router structure)

2. Backend (/backend)
   - Framework: Express 5.2.1, Node.js
   - Database: MongoDB (Mongoose 9.0.1)
   - Realtime: Socket.io 4.8.1 (with Redis Adapter support)
   - Structure: MVC (Controllers, Models, Routes, Services)

3. Shared / Infrastructure
   - Redis: Used for Socket.io adapter (scaling) and caching (Room lists)
   - Auth: Firebase Admin SDK (Backend) + Firebase Client (Frontend)

================================================================================
SECTION 2: FRONTEND ARCHITECTURE (CURRENT STATE)
================================================================================
Framework: Next.js 16.0.7 (Latest) + App Router.

State Management:
- Context API (AuthContext, TourContext)
- Local State (useState) + Custom Hooks (useRooms, useMessages)
- "Refresh Trigger" Pattern: Hooks listen to Socket events and increment a counter to trigger full list re-fetches.

Data Fetching:
- Transitioned from Firestore SDK to Custom REST API (`/lib/api.ts`).
- Hooks (`hooks/useFirestore.ts`) wrap Axios calls.
- SWR/TanStack Query is NOT used (Manual useEffect + loading states).

Bottlenecks & Status:
- [CRITICAL] Re-Render Strategy: Receiving a socket event (e.g., 'room:updated') triggers a full re-fetch of lists via `refreshTrigger`. This will cause massive read spikes at scale.
- Optimistic Updates: Minimal. Most actions require waiting for API + Socket roundtrip.
- Full Reloads: Not required generally, but "hard refreshes" often needed to sync state due to missing socket handlers for some events.

Page Status:
- [Functional] /auth (Sign In/Up)
- [Functional] /dashboard (Discovery)
- [Partial]    /circles/[id] (Chat works, but pagination is missing)
- [Partial]    /startups (CRUD works, application flow complex)
- [Broken]     /profile (Visual only, some edit wiring missing)

================================================================================
SECTION 3: BACKEND ARCHITECTURE (CURRENT STATE)
================================================================================
Framework: Express.js 5.2.1 (Hybrid REST + Socket.io)

Auth Flow:
- Frontend gets ID Token from Firebase.
- Request header `Authorization: Bearer <token>`.
- Middleware `AuthRequest` verifies token via Firebase Admin SDK.
- User is looked up in MongoDB by `firebaseUid`.

API Stability:
- REST Structure: Solid (/api/v1/rooms, /api/v1/opportunities).
- Error Handling: Inconsistent. Some controllers return `{ error: msg }`, others `{ message: msg }`. (Frontend `sign-in.tsx` recently patched to handle both).
- Logging: Basic `console.log`. No structured logging (Winston/Pino) or APM.

Status:
- [Stable] Room Management (CRUD, Join, Leave)
- [Stable] Auth Middleware
- [Incomplete] Analytics (Stubbed responses)
- [Flaky] Notifications (Reliability depends on socket connection; fallback polling used in FE `useNotifications`).

================================================================================
SECTION 4: MESSAGING & CIRCLES SYSTEM
================================================================================
Architecture: Socket.io (Push-based) + REST (History)

Sending:
- Client emits `send_message` (or POST to API).
- Server defines `sendMessage` controller -> Saves to DB -> Emits `new_message` to Room.

Receiving:
- Client listens to `new_message`.
- Deduplication logic exists in `useRoomMessages.ts` (checks `prev.some`).

Typing Indicators:
- Fully functional. Broadcasts `typing` / `stop_typing` events to room (sender excluded).

Read Status:
- [Bottleneck] Implemented as `readBy: [{ user, date }]` array in Message document.
- In a group of 1,000 users, one message document will grow by 1,000 objects.
- Realtime update of "Read" status is stubbed in `socket.ts` (Comment: "Ideally server updates DB then broadcasts").

Pagination:
- [MISSING] `useRoomMessages.ts` explicitly warns: "Load more not fully implemented".
- Chat loads last 50 messages. Scrolling up does NOT load older history.

Race Conditions:
- "Refresh Trigger" causes race between Socket update and API re-fetch. User might see message A (Socket), then list refreshes (API), causing flicker or re-order.

================================================================================
SECTION 5: NOTIFICATIONS SYSTEM
================================================================================
Architecture: Hybrid (Socket Pushes + Polling Fallback).

Creation:
- Triggered by Controllers (e.g., `collaborationController`, `roomController`).
- Saved to `Notification` collection.

Delivery:
- Realtime: `io.to('user:UID').emit('notification:new')`.
- Fallback: Frontend `useNotifications` polls `/notifications` every 30 seconds.

Counters:
- Calculated on frontend (`notifications.filter(n => !n.isRead).length`).
- No backend "unread count" endpoint (inefficient for large lists).

Delays:
- Notifications appear instantly if socket connected.
- If socket drops, delay is up to 30s (Polling interval).

================================================================================
SECTION 6: DATABASE (MONGODB) STATUS
================================================================================
Collections:
- Users, Rooms, RoomMemberships, Messages, Notifications, Opportunities, Applications, CollaborationRequests.

Schema & Indexes:
- Messages: Indexed by `room` and `createdAt`. (Good).
- RoomMemberships: Unclear if compound index `(room, user)` exists. (Critical for frequent "Am I a member?" checks).
- Notifications: Likely indexed by `recipient`.

Heavy Read Paths:
- `getRooms` (Rooms Listing): Reads `Room` + `RoomMembership` (All memberships for user) to determine access/status. Expensive aggregation-like logic in code.
- `Message` History: No pagination = fast now, unusable later.

================================================================================
SECTION 7: REALTIME / PERFORMANCE ANALYSIS
================================================================================
Why app feels slow (analysis):
1. [Frontend] Re-fetching EVERYTHING on minor updates. A single "Member Joined" event causes `fetchRooms` -> GET `/rooms` + GET `/rooms/me` -> map/merge.
2. [Backend] `getMyRooms` performs "Batch Query" manually instead of optimized aggregation.

UI Blocking:
- `useRooms` loading state blocks the list view entirely during background refresh.

Scalability Limit (1k Users):
- The `refreshTrigger` pattern is the killer. If 1,000 users are in a generic "General" room, and one joins, 1,000 clients hit GET `/rooms`.
- This is an inadvertent DDoS attack on self.

================================================================================
SECTION 8: DEPLOYMENT & INFRA
================================================================================
- Frontend: Vercel (likely).
- Backend: Render/Heroku (Stateful/Node).
- Redis: Configured (`socket.ts` checks `REDIS_URL`). Required for multiple backend instances.
- CORS: `socket.ts` configured for `origin: '*'`. Security risk for production.

================================================================================
SECTION 9: SECURITY & STABILITY
================================================================================
- [Risk] CORS `*` in Socket.io.
- [Risk] Collab Request "Admin" check relies on `myRole` which was just added. Before this, UI filtered strictly by Owner. Logic is now safer.
- [Leak] `getRooms` returns member counts but logic checks generic `isPrivate`. Ensure `isPrivate` rooms are strictly filtered from public lists (seems handled).

================================================================================
SECTION 10: KNOWN BUGS & INCOMPLETE FEATURES
================================================================================
- [Bug] Chat History Pagination is missing. Old messages are inaccessible.
- [Incomplete] "Read Receipts" do not update in realtime reliably.
- [Incomplete] Analytics page works but data is mocked/stubbed.
- [UX] Profile page editing is partially wired.

================================================================================
SECTION 11: SCALING READINESS (HONEST ASSESSMENT)
================================================================================
- 100 Users: Works fine.
- 1,000 Users:
  - Chat works (Redis Adapter helps).
  - Lists will lag due to "Refetch on Event" pattern.
  - DB hits will spike dangerously.
- 10,000 Users:
  - Message `readBy` array will hit document size limits or cause massive IO.
  - `getRooms` logic (JavaScript-side join of Memberships) will timeout CPU.
  - System is NOT ready for 10k.

================================================================================
SECTION 12: SUGGESTED NEXT STEPS (DO NOT IMPLEMENT)
================================================================================
1. [Critical] Implement Cursor-based Pagination for Chat (Backend & Frontend).
2. [Critical] Remove "Refetch on Event" pattern. Update Local State optimistically using the Socket payload (e.g., `setRooms(prev => [...prev, newRoom])`).
3. [Database] Move `readBy` out of Message document into a separate `MessageReadStatus` collection or use "Watermark" approach (User X read up to Message Y).
4. [Infra] Tighten CORS policy.
